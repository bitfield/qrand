[![Go Reference](https://pkg.go.dev/badge/github.com/bitfield/qrand.svg)](https://pkg.go.dev/github.com/bitfield/qrand)
[![Go Report Card](https://goreportcard.com/badge/github.com/bitfield/qrand)](https://goreportcard.com/report/github.com/bitfield/qrand)
[![Mentioned in Awesome Go](https://awesome.re/mentioned-badge-flat.svg)](https://github.com/avelino/awesome-go)
![Tests](https://github.com/bitfield/qrand/actions/workflows/test.yml/badge.svg)

# What is `qrand`?

`qrand` is a Go library that provides random numbers generated by a non-deterministic, quantum-mechanical process. 

```go
import "github.com/bitfield/qrand"
```

The random data is provided by Australia National University's [quantum randomness API](https://quantumnumbers.anu.edu.au/) (you'll need an API key for this, but it's free for limited use).

# The CLI tool

There's a simple CLI tool to request and display a given number of random (hex) bytes. To install it:

```sh
go install github.com/bitfield/qrand/cmd/qrand@latest
```

To use it, pick the number of bytes you need (for example, 32), and run:

```sh
qrand 32
```
```
8e8c2771be5c2bb10d541a5bf6aa51203e0bce2d6d4fa267afd89a6e20df11f1
```

# Sources of randomness

> *Random numbers should not be generated with a method chosen at random.*
>
> —Donald Knuth, [“The Art of Computer Programming, Vol 2: Seminumerical Algorithms”](https://amzn.to/3Y8uMt3)

Most computer random number generators (RNGs) use a deterministic process, which means that given an initial seed value, the sequence of generated numbers is predictable.

For example, Go's standard `math/rand` library uses a fairly simple algorithm to generate a random-looking, but still deterministic sequence of numbers. For most applications this is absolutely fine when seeded with a suitable value, such as the current Unix time in nanoseconds (which is the default from Go 1.20 onwards). For any cryptographic purposes, though, `math/rand` is entirely unsuitable, and we should use `crypto/rand` instead.

`crypto/rand` will use the most secure randomness source provided by the operating system; for example, on Linux systems this might be the `/dev/urandom` device. While this is still a pseudo-random source, it uses environmental 'noise' such as I/O activity, keystrokes, and so on, to generate numbers which are in practice (though not in principle) unpredictable.

For very high-security applications, though, we can use quantum-mechanical sources, such as the cosmic microwave background radiation ([Lee and Cleaver 2017](https://www.sciencedirect.com/science/article/pii/S2405844017310897)). The outcomes of quantum measurements, such as the spin of an electron or the polarization of a photon, are _in principle_ unpredictable, to the best of our knowledge ([Bierhorst et al. 2018](https://www.nature.com/articles/s41586-018-0019-0)).

# The ANU randomness server

Various types of hardware quantum RNG devices are available. Australia National University provides a [public quantum randomness source](https://quantumnumbers.anu.edu.au/) generated by a device that uses a laser to measure the quantum fluctuations of the vacuum ([Symul, Assad, and Lam 2011](https://aip.scitation.org/doi/10.1063/1.3597793); [Haw et al. 2015](https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.3.054004)).

# Why do I need quantum randomness?

You don't. The standard randomness source provided by your operating system, available via `crypto/rand`, is almost certainly good enough for any application requiring strong randomness, such as cryptography (otherwise, we're all in trouble).

However, it's fun to use a source of randomness which is entirely non-deterministic (so far as we know) and provided directly by the Universe itself. 

# Examples

Here are a couple of example programs that show how you might use `qrand`.

## Reading random bytes

A common use of `crypto/rand` in Go programs is to read a sequence of securely random bytes (an initialization vector, for example). `qrand` can do the same thing, but deriving its data from the quantum randomness provider.

The [`numbers`](example/numbers/main.go) example shows how to do this:

```go
q := qrand.NewReader(apiKey)
numbers := make([]byte, 10)
_, err := q.Read(numbers)
```

As you can see, this is very similar to the [equivalent `crypto/rand` program](https://pkg.go.dev/crypto/rand#example-Read). The only difference is that we need to create the reader first with `NewReader`, because the provider requires an API key.

## Generating random numbers

`math/rand`, on the other hand, is commonly used to provide random numbers, using something like `rand.Intn`. This is useful in games, for example, or other programs that need “random-seeming” behaviour without strict cryptographic security.

We can do something similar with `qrand`, by creating a *randomness source*. 
The [`password`](example/password/main.go) example shows what this looks like:

```go
rnd := rand.New(qrand.NewSource(qrand.NewReader(apiKey)))
var password [32]byte
for i := range password {
    password[i] = chars[rnd.Intn(len(chars))]
}
```
